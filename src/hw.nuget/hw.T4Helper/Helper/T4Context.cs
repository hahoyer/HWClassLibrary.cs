using System.Text;
using EnvDTE;
using hw.DebugFormatter;
using Microsoft.VisualStudio.TextTemplating;

// ReSharper disable CheckNamespace

namespace hw.Helper;

public sealed class T4Context
{
    const string RegionName = "Generated Code";
    const string RegionFrame = "#region {0}\n\n{1}#endregion {0}\n";
    const string HeaderText = "// Generated by {0}\n// Timestamp: {1}\n";

    readonly FunctionCache<string, Box<string>> FileItems;
    readonly StringBuilder Text;
    readonly ITextTemplatingEngineHost Host;
    readonly ValueCache<DTE> EnvDTE;
    string[] CurrentFiles;
    int CurrentStart;

    [UsedImplicitly]
    public string NameSpace
        => Host.ResolveParameterValue("directiveId", "namespaceDirectiveProcessor", "namespaceHint") ?? "";

    [UsedImplicitly]
    public string File
    {
        set
        {
            if(value == null)
                SetFiles();
            else
                SetFiles(value);
        }
    }

    string MainFileName => Path.GetFileNameWithoutExtension(Host.TemplateFile);
    string MainPath => Path.GetDirectoryName(Host.TemplateFile);
    static string Extension => ".cs";
    string FullMainFileName => MainPath.PathCombine(MainFileName) + Extension;

    DTE Dte => EnvDTE.Value;

    string TimeDependantHeader => string.Format(HeaderText, GetType().FullName, DateTime.Now.ToString("o"));

    internal T4Context(StringBuilder text, ITextTemplatingEngineHost host)
    {
        Text = text;
        Host = host;
        FileItems = new(fileName => new(""));
        EnvDTE = new(ObtainDte);
    }

    [UsedImplicitly]
    public void SetFiles(params string[] files)
    {
        OnFilesChanging();
        (CurrentFiles == null).Assert();
        // Special treatment of empty file list: send text to default target
        if(files.Length > 0)
            CurrentFiles = files;
    }

    [UsedImplicitly]
    public void ProcessFiles()
    {
        OnFilesChanging();
        //Tracer.LaunchDebugger();
        TreatMainFile();
        foreach(var fileItem in FileItems)
            CreateFile(MainPath.PathCombine(fileItem.Key), fileItem.Value.Content);

        var newFiles = FileItems.Keys.Select(name => MainPath.PathCombine(name)).ToArray();

        var projectSyncAction = () => ProjectSync(newFiles);
        projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(null, null));
    }

    void TreatMainFile()
    {
        var text = CreateFile(FullMainFileName, Text.ToString());
        Text.Clear();
        Text.Append(text);
    }

    void OnFilesChanging()
    {
        if(CurrentFiles != null)
        {
            foreach(var box in CurrentFiles.Select(file => FileItems[file]))
                box.Content += Text.ToString(CurrentStart, Text.Length - CurrentStart);
            Text.Remove(CurrentStart, Text.Length - CurrentStart);
        }

        CurrentFiles = null;
        CurrentStart = Text.Length;
    }

    string CreateFile(string fileName, string content)
    {
        var regioned = ModificationSensitiveContent(content);

        var oldFile = fileName.ToSmbFile();
        var result = oldFile.String;
        if(result != null && result.EndsWith(regioned))
            return result;

        CheckoutFileIfRequired(fileName);
        result = TimeDependantHeader + regioned;
        fileName.ToSmbFile().String = result;
        return result;
    }

    static string ModificationSensitiveContent(string content) => string.Format(RegionFrame, RegionName, content);

    void CheckoutFileIfRequired(string fileName)
    {
        if(Dte == null
           || Dte.SourceControl == null
           || !Dte.SourceControl.IsItemUnderSCC(fileName)
           || Dte.SourceControl.IsItemCheckedOut(fileName))
            return;

        Action<string> checkOutAction = name => Dte.SourceControl.CheckOutItem(name);
        checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
    }

    void ProjectSync(string[] newFiles)
    {
        if(Dte == null)
            return;

        var item = Dte.Solution.FindProjectItem(Host.TemplateFile);
        if(item == null || item.ProjectItems == null)
            return;

        var projectFiles = item.ProjectItems.Cast<ProjectItem>().ToDictionary(projectItem => projectItem.FileNames[0]);

        // Remove unused items from the project
        var toDelete = projectFiles.Where(pair => !newFiles.Contains(pair.Key) && pair.Key != FullMainFileName);
        foreach(var pair in toDelete)
            pair.Value.Delete();

        // Add missing files to the project
        foreach(var fileName in newFiles.Where(fileName => !projectFiles.ContainsKey(fileName)))
            item.ProjectItems.AddFromFile(fileName);
    }

    DTE ObtainDte()
    {
        var provider = Host as IServiceProvider;
        if(provider == null)
            return null;
        return (DTE)provider.GetService(typeof(DTE));
    }

    void AppendText(string text) => Text.Append(text);
}